import chess
import chess.pgn
from langchain_core.prompts import PromptTemplate
from dotenv import load_dotenv, find_dotenv
from langchain.memory import ConversationBufferMemory

from langchain_openai import ChatOpenAI
from langchain_groq import ChatGroq
from langchain.chains import LLMChain
import chess.pgn

_ = load_dotenv(find_dotenv())

llm1 = ChatOpenAI(temperature=0.3, model='gpt-4o')
# llm1 = ChatOpenAI(temperature=0, model='gpt-3.5-turbo')
llm2 = ChatGroq(temperature=0.3, model_name="llama3-70b-8192")

memory = ConversationBufferMemory(memory_key="chat_history", input_key="msg")
memory2 = ConversationBufferMemory(memory_key="chat_history", input_key="msg")

# Definindo os prompts para as LLMs
template = """
    You are a Garry Kasparov. 
    You are currently playing a chess game.
    You have to answer only with the best move you can find.
    
    You are playing with the {color} pieces.

    Here is the game history so far:
    {history}

    Find the best move.

    Your move must be one in the given list of valid moves above.
    Here is a list of valid moves on this position:
    {valid_moves}

    Format you answer to looks exactly like the one you picked in the list.
    
    Your move:
    """
prompt_template = PromptTemplate.from_template(template)

# Criando os LLMChains
# chain1 = LLMChain(llm=llm1, prompt=prompt_template, memory=memory)
# chain2 = LLMChain(llm=llm2, prompt=prompt_template, memory=memory2)

chain1 = prompt_template | llm1
chain2 = prompt_template | llm2

# Inicializando o tabuleiro de xadrez
board = chess.Board()


def get_move(llm_chain, board, color):
    game = chess.pgn.Game.from_board(board)
    history = str(game)
    legal_moves = list(board.legal_moves)
    san_moves = str([board.san(move) for move in legal_moves])

    response = llm_chain.invoke({
        # "board": str(board), 
        "history": history, 
        "color": color, 
        "valid_moves": san_moves})
    
    # move = response["text"]
    move = response.content.strip()
    
    # Validação e correção do movimento
    try:
        board.push_san(move)
        return move
    except ValueError:
        print(f"Invalid move generated by LLM: {move}")
        return None

# Loop de jogo
move_number = 1
while not board.is_game_over():
    move1 = None
    while move1 is None:
        move1 = get_move(chain1, board, "white")
    
    if board.is_game_over():
        break
    
    move2 = None
    while move2 is None:
        move2 = get_move(chain2, board, "black")
    
    game = chess.pgn.Game.from_board(board)
    print(str(game))
    move_number += 1


game = chess.pgn.Game.from_board(board)
print(str(game))

with open("game.pgn", "w") as f:
    f.write(str(game))

print("Game Over")
print(board.result())

