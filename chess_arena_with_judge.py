import chess
import chess.pgn
from langchain_core.prompts import PromptTemplate, ChatPromptTemplate
from dotenv import load_dotenv, find_dotenv
from langchain.memory import ConversationBufferMemory

from langchain_openai import ChatOpenAI
from langchain_groq import ChatGroq
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain.chains import LLMChain
import chess.pgn
import re
import os
_ = load_dotenv(find_dotenv())


# llm = ChatGoogleGenerativeAI(model="gemini-pro")

# white_player = "GPT-4o"
# black_player = "Gemini-Pro"
# llm1 = ChatOpenAI(temperature=0, model='gpt-4o')
# llm2 = ChatGoogleGenerativeAI(temperature=0, model="gemini-1.5-pro-latest")

white_player = "Gemini-Pro"
black_player = "GPT-4o"
llm1 = ChatGoogleGenerativeAI(temperature=0, model="gemini-1.5-pro-latest")
llm2 = ChatOpenAI(temperature=0, model='gpt-4o')

memory = ConversationBufferMemory(memory_key="chat_history", input_key="input")
memory2 = ConversationBufferMemory(memory_key="chat_history", input_key="input")


# Definindo os prompts para as LLMs
system_template = """
    You are a Chess Grandmaster.
    We are currently playing chess. 
    You are playing with the {color} pieces.
    
    I will give you my move, the history of the game so far
    and you must give the best move you can find. 

    # OUTPUT
    Respond only with your move in the SAN notation.
    """

prompt_template1 = ChatPromptTemplate.from_messages([
    ("system", system_template.format(color="white")), 
    ("human", "{input}")])
prompt_template2 = ChatPromptTemplate.from_messages([
    ("system", system_template.format(color="black")), 
    ("human", "{input}")])

# Criando os LLMChains
# chain1 = LLMChain(llm=llm1, prompt=prompt_template1, memory=memory)
# chain2 = LLMChain(llm=llm2, prompt=prompt_template2, memory=memory2)
chain1 = prompt_template1 | llm1
chain2 = prompt_template2 | llm2

judge_template = """
    You are a professional chess arbiter, working on a LLM's Chess Competition.

    Your job is to parse last player's move and ensure that all chess moves are valid and correctly formatted in 
    Standard Algebraic Notation (SAN) for processing by the python-chess library.

    ### Input:
    - Board state observed by the player and his move
    - List of valid moves in SAN

    ### Output:
    - Return the corresponding move in the list of valid SAN moves.
    - If the proposed move is not in the valid moves list, must respond with "None"

    ### Your turn:
    - Proposed move: {proposed_move}
    - Valid moves: {valid_moves}

    You should only respond the valid move, without the move number, nothing more.
    Your response:
    """
llm3 = ChatGroq(temperature=0, model_name="llama3-70b-8192")
judge_prompt = PromptTemplate.from_template(template=judge_template)
chain3 = judge_prompt | llm3

move_raw = ""
def get_move(llm_chain, last_move, board, color, alert_msg=False):
    global chain3, move_raw
    game = chess.pgn.Game.from_board(board)
    str_board = str(board)
    history = str(game)
    pattern = r".*?(?=1\. e4)"
    history = re.sub(pattern, "", history, flags=re.DOTALL)

    legal_moves = list(board.legal_moves)
    san_moves = str([board.san(move) for move in legal_moves])

    template_input="""
        Here's the history of the game:
        {history}

        My last move: {move}
    """
    
    if not alert_msg:
        user_input = template_input.format(move=last_move,
                                        #    san_moves=san_moves,                                           
                                           history=history)
    else:  
        user_input="""
        You've made a confusion!

        My move was: {last_move}

        Here is the game history so far:
        {history}
        
        You tried to play {move_raw}, but its not a valid move!

        Here's a list of valid moves in this position:
        {san_moves}   
        """.format(san_moves=san_moves, 
                history=history, 
                # str_board=str_board,
                move_raw=move_raw,
                last_move=last_move)
    
    response = llm_chain.invoke({"input": user_input})
    # move_raw = response["text"].strip()
    move_raw = response.content.strip()
    
    try:
        if alert_msg:
            print("Alerting player")
            print(response)

        move = chain3.invoke({"proposed_move": move_raw,
                "valid_moves": san_moves
            }).content.strip()
        print(f"Old move: {move_raw}, New move: {move}")
        board.push_san(move)            
        return move
    
    except ValueError:
        print(f"Invalid move generated by {color}: {move}")
        return None


# Inicializando o tabuleiro de xadrez
for move1 in ["1. e4", "1. d4", "1. c4", "1. Nf3", "1. b3", "1. c3", "1. e3", "1. d3", "1. g3", "1. Nc3"]:
    print("============")
    print(f"New Game with {move1}")
    board = chess.Board()

    # Loop de jogo
    board.push_san(move1.split()[-1])
    while not board.is_game_over():    
        move2 = None
        c = 0
        while move2 is None:
            alert = False if c == 0 else True
            move2 = get_move(chain2, move1, board, "black", alert)
            c += 1
        
        if board.is_game_over():
            break
        
        move1 = None
        c = 0
        while move1 is None:
            alert = False if c == 0 else True
            move1 = get_move(chain1, move2, board, "white", alert)
            c+=1
        
        game = chess.pgn.Game.from_board(board)
        print(str(game))

    game = chess.pgn.Game.from_board(board)
    game.headers["White"] = white_player
    game.headers["Black"] = black_player
    print(str(game))


    folder_name = f"{white_player} vs {black_player}"
    if not os.path.exists(folder_name):
        os.makedirs(folder_name)
    game_num = max([int(i.split("_")[0]) for i in ["0_0"]+ os.listdir(folder_name)]) + 1
    with open(f"{folder_name}/{game_num}_game.pgn", "w") as f:
        f.write(str(game))

    print("Game Over")
    print(board.result())
